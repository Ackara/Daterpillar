<#@ include file="../../T4Helper.ttinclude" #>
<#  
	string className = Path.GetFileNameWithoutExtension(Host.TemplateFile); 
	string dictionaryName = "TypeMap"; 
#>
using System.Collections.Generic;
using Acklann.Daterpillar.Configuration;

namespace <#= Host.ResolveAssemblyReference("$(RootNamespace)") #>.Compilation.Resolvers
{
	/// <summary>
	/// Defines a method that maps a <#= GetXmlNamespace() #> TypeName to another language's type name.
	/// </summary>
	/// <seealso cref="ITypeResolver" />
	public abstract class <#= className #> : ITypeResolver
	{
		#region Keys

<#
	PushIndent("\t\t");
	foreach ((string typeName, string doc) in GetXsdEnumerations("TypeName"))
	{
		WriteLine($"/// <summary>{typeName}.</summary>");
		WriteLine($"internal const string {typeName.ToUpper()} = \"{typeName.ToLower()}\";");
	}
	ClearIndent();
#>

		#endregion Keys

		/// <summary>
		/// Initializes a new instance of the <see cref="<#= className #>"/> class.
		/// </summary>
		public <#= className #>()
		{
			<#= dictionaryName #> = new Dictionary<string, string>
			{
<#
	PushIndent("\t\t\t\t");
	foreach ((string value, string doc) in GetXsdEnumerations("TypeName"))
	{
		WriteLine($"{{ \"{value.ToLower()}\", \"{value.ToUpper()}\" }},");
	}
	
	ClearIndent();
#>
			};
		}

		/// <summary>
        /// Escapes the specified object name.
        /// </summary>
        /// <param name="objectName">Name of the object.</param>
        /// <returns>The escaped name.</returns>
		public virtual string Escape(string objectName) => objectName;

		/// <summary>
		/// Maps the specified <see cref="DataType"/>.
		/// </summary>
		/// <param name="dataType">Type of the data.</param>
		/// <returns>The type name.</returns>
		public abstract string GetTypeName(DataType dataType);

		public virtual string GetActionName(ReferentialAction action)
        {
			switch (action)
            {
				default:
				case ReferentialAction.Cascade:
					return "CASCADE";

                case ReferentialAction.NoAction:
                    return "NO ACTION";
                
                case ReferentialAction.Restrict:
                    return "RESTRICT";

                case ReferentialAction.SetNull:
                    return "SET NULL";

                case ReferentialAction.SetDefault:
                    return "SET DEFAULT";
            }
        }

		/// <summary>
		/// Gets or sets the type-to-type map.
		/// </summary>
		protected IDictionary<string, string> <#= dictionaryName #> { get; set; }
	}
}