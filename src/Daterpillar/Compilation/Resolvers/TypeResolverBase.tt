<#@ include file="../../T4Helper.ttinclude" #>
<#  
	string className = Path.GetFileNameWithoutExtension(Host.TemplateFile); 
	string dictionaryName = "TypeMap"; 
#>
using System.Collections.Generic;
using Acklann.Daterpillar.Configuration;

namespace <#= Host.ResolveAssemblyReference("$(RootNamespace)") #>.Compilation.Resolvers
{
	/// <summary>
	/// Defines a method that maps a <#= GetXmlNamespace() #> TypeName to another language's type name.
	/// </summary>
	/// <seealso cref="ITypeResolver" />
	public abstract class <#= className #> : ITypeResolver
	{
		#region Keys

<#
	PushIndent("\t\t");
	foreach (var typeName in GetXsdEnumerations("TypeName"))
	{
		WriteLine($"/// <summary>{typeName}.</summary>");
		WriteLine($"public const string {typeName.ToUpper()} = \"{typeName}\";");
	}
	ClearIndent();
#>

		#endregion Keys

		/// <summary>
		/// Initializes a new instance of the <see cref="<#= className #>"/> class.
		/// </summary>
		public <#= className #>()
		{
			<#= dictionaryName #> = new Dictionary<string, string>
			{
<#
	PushIndent("\t\t\t\t");
	foreach (var value in GetXsdEnumerations("TypeName"))
	{
		WriteLine($"{{ \"{value.ToLower()}\", \"{value.ToLower()}\" }},");
	}
	
	ClearIndent();
#>
			};
		}

		/// <summary>
		/// Maps the specified <see cref="DataType"/>.
		/// </summary>
		/// <param name="dataType">Type of the data.</param>
		/// <returns>The type name.</returns>
		public abstract string GetTypeName(DataType dataType);

		/// <summary>
		/// Gets or sets the type-to-type map.
		/// </summary>
		protected IDictionary<string, string> <#= dictionaryName #> { get; set; }
	}
}